-- Mys2 Hub | Xeno-Compatible GUI (TP Float Edition)

local player = game.Players.LocalPlayer
repeat wait() until player.Character and player.Character:FindFirstChild("HumanoidRootPart")
local char = player.Character
local hrp = char:WaitForChild("HumanoidRootPart")
local humanoid = char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid")

local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")

local speedEnabled = getgenv()._speedToggle or false
local desiredSpeed = 90

-- Discord Integration
local discordInvite = "https://discord.gg/spnTPXSvMk"
local discordWebhook = "https://discord.com/api/webhooks/1396066702965346316/NDb7LEGDE9b5y3ymYEyuJcJdfOm8xotkuGNVsqTbfxkFmH4PKEsRc5GWaROkA8iZBqU6"

local function sendDiscordWebhookNotification()
    local data = {
        content = "**Mys2 Hub script loaded**\nUser: " .. player.Name,
        username = "Mys2 Hub Bot"
    }

    local success, err = pcall(function()
        HttpService:PostAsync(discordWebhook, HttpService:JSONEncode(data), Enum.HttpContentType.ApplicationJson)
    end)

    if not success then
        warn("Failed to send Discord webhook: " .. tostring(err))
    end
end

local function showDiscordPopup()
    local popupGui = Instance.new("ScreenGui", game.CoreGui)
    popupGui.Name = "DiscordInvitePopup"

    local popupFrame = Instance.new("Frame", popupGui)
    popupFrame.Size = UDim2.new(0, 300, 0, 150)
    popupFrame.Position = UDim2.new(0.5, -150, 0.5, -75)
    popupFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    popupFrame.BorderSizePixel = 0
    popupFrame.Active = true
    popupFrame.Draggable = true

    local title = Instance.new("TextLabel", popupFrame)
    title.Size = UDim2.new(1, 0, 0, 30)
    title.BackgroundTransparency = 1
    title.Text = "Script Update Available!"
    title.TextColor3 = Color3.new(1, 1, 1)
    title.Font = Enum.Font.GothamBold
    title.TextSize = 18

    local message = Instance.new("TextLabel", popupFrame)
    message.Size = UDim2.new(1, -20, 0, 70)
    message.Position = UDim2.new(0, 10, 0, 40)
    message.BackgroundTransparency = 1
    message.TextWrapped = true
    message.Text = "A new script update is available.\nJoin our Discord server to stay updated and get support!"
    message.TextColor3 = Color3.new(1, 1, 1)
    message.Font = Enum.Font.Gotham
    message.TextSize = 14

    local inviteButton = Instance.new("TextButton", popupFrame)
    inviteButton.Size = UDim2.new(0, 200, 0, 30)
    inviteButton.Position = UDim2.new(0.5, -100, 1, -50)
    inviteButton.BackgroundColor3 = Color3.fromRGB(114, 137, 218) -- Discord blurple
    inviteButton.Text = "Join Discord"
    inviteButton.TextColor3 = Color3.new(1, 1, 1)
    inviteButton.Font = Enum.Font.GothamBold
    inviteButton.TextSize = 16

    local closeButton = Instance.new("TextButton", popupFrame)
    closeButton.Size = UDim2.new(0, 30, 0, 30)
    closeButton.Position = UDim2.new(1, -35, 0, 5)
    closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    closeButton.Text = "X"
    closeButton.TextColor3 = Color3.new(1, 1, 1)
    closeButton.Font = Enum.Font.GothamBold
    closeButton.TextSize = 18

    inviteButton.MouseButton1Click:Connect(function()
        if setclipboard then
            setclipboard(discordInvite)
        end
        print("Discord invite copied to clipboard!")
    end)

    closeButton.MouseButton1Click:Connect(function()
        popupGui:Destroy()
    end)
end

-- GUI Setup for Mys2 Hub
local gui = Instance.new("ScreenGui", game.CoreGui)
gui.Name = "Mys2Hub"

local frame = Instance.new("Frame", gui)
frame.Size = UDim2.new(0, 200, 0, 400)
frame.Position = UDim2.new(0, 20, 0, 100)
frame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
frame.BorderSizePixel = 0
frame.Active = true
frame.Draggable = true

local title = Instance.new("TextLabel", frame)
title.Size = UDim2.new(1, 0, 0, 30)
title.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
title.Text = "Mys2 Hub"
title.TextColor3 = Color3.new(1, 1, 1)
title.Font = Enum.Font.GothamBold
title.TextSize = 16

local nextButtonY = 40
function autoToggle(name, callback)
    local btn = Instance.new("TextButton", frame)
    btn.Size = UDim2.new(1, -20, 0, 30)
    btn.Position = UDim2.new(0, 10, 0, nextButtonY)
    btn.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    btn.TextColor3 = Color3.new(1, 1, 1)
    btn.Font = Enum.Font.Gotham
    btn.TextSize = 14
    btn.Text = name .. ": OFF"

    local enabled = false
    btn.MouseButton1Click:Connect(function()
        enabled = not enabled
        btn.Text = name .. ": " .. (enabled and "ON" or "OFF")
        callback(enabled)
    end)

    nextButtonY = nextButtonY + 40
end

function autoButton(name, callback)
    local btn = Instance.new("TextButton", frame)
    btn.Size = UDim2.new(1, -20, 0, 30)
    btn.Position = UDim2.new(0, 10, 0, nextButtonY)
    btn.BackgroundColor3 = Color3.fromRGB(60, 0, 0)
    btn.TextColor3 = Color3.new(1, 1, 1)
    btn.Font = Enum.Font.Gotham
    btn.TextSize = 14
    btn.Text = name
    btn.MouseButton1Click:Connect(callback)

    nextButtonY = nextButtonY + 40
end

-- Speed logic
local speedConnection

local function enforceSpeed()
    if speedEnabled and humanoid and humanoid.Parent then
        humanoid.WalkSpeed = desiredSpeed
    elseif humanoid then
        humanoid.WalkSpeed = 16
    end
end

local function startSpeedEnforcement()
    if speedConnection then speedConnection:Disconnect() end
    speedConnection = RunService.Heartbeat:Connect(enforceSpeed)
end

local function stopSpeedEnforcement()
    if speedConnection then
        speedConnection:Disconnect()
        speedConnection = nil
    end
    if humanoid then
        humanoid.WalkSpeed = 16
    end
end

local function hookWalkSpeed()
    local success, mt = pcall(getrawmetatable, game)
    if success and mt then
        local oldIndex = mt.__index
        local oldNewIndex = mt.__newindex
        setreadonly(mt, false)

        mt.__index = newcclosure(function(t, k)
            if t == humanoid and k == "WalkSpeed" and speedEnabled then
                return desiredSpeed
            end
            return oldIndex(t, k)
        end)

        mt.__newindex = newcclosure(function(t, k, v)
            if t == humanoid and k == "WalkSpeed" and speedEnabled then
                return
            end
            return oldNewIndex(t, k, v)
        end)

        setreadonly(mt, true)
    end
end

-- Teleport logic
local function tpUp()
    if hrp then
        local pos = hrp.Position
        hrp.CFrame = CFrame.new(pos.X, 300, pos.Z) -- Changed from 1000 to 300
    end
end

local function tpDown()
    if hrp then
        local pos = hrp.Position
        hrp.CFrame = CFrame.new(pos.X, 10, pos.Z)
    end
end

local function teleportToClosest()
    local closest, dist = nil, math.huge
    for _, other in pairs(game.Players:GetPlayers()) do
        if other ~= player and other.Character and other.Character:FindFirstChild("HumanoidRootPart") then
            local d = (hrp.Position - other.Character.HumanoidRootPart.Position).Magnitude
            if d < dist then
                dist = d
                closest = other
            end
        end
    end
    if closest then
        hrp.CFrame = closest.Character.HumanoidRootPart.CFrame * CFrame.new(0, 5, 0)
    end
end

-- ESP Data tables
local brainrotGodRates = {
    ["Cocofanto Elefanto"] = {moneyPerSec = "10K", sellsFor = "5M"},
    ["Girafa Celestre"] = {moneyPerSec = "20K", sellsFor = "7.5M"},
    ["Gattatino Neonino"] = {moneyPerSec = "35K", sellsFor = "7.5M"},
    ["Matteo"] = {moneyPerSec = "50K", sellsFor = "10M"},
    ["Tralalero Tralala"] = {moneyPerSec = "50K", sellsFor = "10M"},
    ["Espresso Signora"] = {moneyPerSec = "70K", sellsFor = "25M"},
    ["Odin Din Din Dun"] = {moneyPerSec = "75K", sellsFor = "15M"},
    ["Statutino Libertino"] = {moneyPerSec = "75K", sellsFor = "20M"},
    ["Trenostruzzo Turbo 3000"] = {moneyPerSec = "150K", sellsFor = "25M"},
    ["Ballerino Lololo"] = {moneyPerSec = "200K", sellsFor = "35M"},
    ["Tigroligre Frutonni"] = {moneyPerSec = "60K", sellsFor = "15M"},
    ["Orcalero Orcala"] = {moneyPerSec = "100K", sellsFor = "15M"},
}

local mythicRates = {
    ["Frigo Camelo"] = {moneyPerSec = "1.2K", sellsFor = "300K"},
    ["Orangutini Ananassini"] = {moneyPerSec = "1.7K", sellsFor = "400K"},
    ["Rhino Toasterino"] = {moneyPerSec = "2.1K", sellsFor = "450K"},
    ["Bombardiro Crocodilo"] = {moneyPerSec = "2.5K", sellsFor = "500K"},
    ["Bombombini Gusini"] = {moneyPerSec = "5K", sellsFor = "1M"},
    ["Cavallo Virtuoso"] = {moneyPerSec = "7.5K", sellsFor = "2.5M"},
    ["Spioniro Golubiro"] = {moneyPerSec = "3.5K", sellsFor = "750K"},
    ["Zibra Zubra Zibralini"] = {moneyPerSec = "6K", sellsFor = "1M"},
    ["Tigrilini Watermelini"] = {moneyPerSec = "7.5K", sellsFor = "1M"},
}

-- ESP State
local playerESPEnabled = false
local godsESPEnabled = false
local mythicsESPEnabled = false

-- Drawing objects tables
local playerBoxes = {}
local godsBoxes = {}
local mythicsBoxes = {}

-- Helper to create ESP box + text for NPCs
local function createESPBox(color)
    local box = Drawing.new("Square")
    box.Visible = false
    box.Color = color
    box.Thickness = 2
    box.Filled = false

    local text = Drawing.new("Text")
    text.Visible = false
    text.Center = true
    text.Color = color
    text.Size = 16
    text.Outline = true
    text.Font = 2 -- UI font

    return {box = box, text = text}
end

-- Player ESP (fixed)
local function createPlayerESPBox()
    local box = Drawing.new("Square")
    box.Visible = false
    box.Color = Color3.new(1, 1, 1) -- White for players
    box.Thickness = 2
    box.Filled = false

    local text = Drawing.new("Text")
    text.Visible = false
    text.Center = true
    text.Color = Color3.new(1, 1, 1)
    text.Size = 16
    text.Outline = true
    text.Font = 2 -- UI font

    return {box = box, text = text}
end

local function cleanPlayerBoxes()
    for plr, drawObjs in pairs(playerBoxes) do
        if not plr.Parent or not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") then
            drawObjs.box:Remove()
            drawObjs.text:Remove()
            playerBoxes[plr] = nil
        end
    end
end

-- ESP Update Loop
RunService.RenderStepped:Connect(function()
    local camera = workspace.CurrentCamera

    -- Player ESP
    if playerESPEnabled then
        cleanPlayerBoxes()

        for _, plr in pairs(game.Players:GetPlayers()) do
            if plr ~= player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                if not playerBoxes[plr] then
                    playerBoxes[plr] = createPlayerESPBox()
                end
                local hrp = plr.Character.HumanoidRootPart
                local pos, onScreen = camera:WorldToViewportPoint(hrp.Position)
                local drawObjs = playerBoxes[plr]

                if onScreen then
                    local size = Vector3.new(2, 5, 2)
                    local corners = {
                        camera:WorldToViewportPoint(hrp.Position + Vector3.new(-size.X, size.Y, -size.Z)),
                        camera:WorldToViewportPoint(hrp.Position + Vector3.new(size.X, size.Y, -size.Z)),
                        camera:WorldToViewportPoint(hrp.Position + Vector3.new(-size.X, size.Y, size.Z)),
                        camera:WorldToViewportPoint(hrp.Position + Vector3.new(size.X, size.Y, size.Z)),
                        camera:WorldToViewportPoint(hrp.Position + Vector3.new(-size.X, -size.Y, -size.Z)),
                        camera:WorldToViewportPoint(hrp.Position + Vector3.new(size.X, -size.Y, -size.Z)),
                        camera:WorldToViewportPoint(hrp.Position + Vector3.new(-size.X, -size.Y, size.Z)),
                        camera:WorldToViewportPoint(hrp.Position + Vector3.new(size.X, -size.Y, size.Z)),
                    }
                    local xs, ys = {}, {}
                    for _, corner in pairs(corners) do
                        table.insert(xs, corner.X)
                        table.insert(ys, corner.Y)
                    end
                    local minX, maxX = math.min(table.unpack(xs)), math.max(table.unpack(xs))
                    local minY, maxY = math.min(table.unpack(ys)), math.max(table.unpack(ys))

                    drawObjs.box.Position = Vector2.new(minX, minY)
                    drawObjs.box.Size = Vector2.new(maxX - minX, maxY - minY)
                    drawObjs.box.Visible = true

                    drawObjs.text.Text = plr.Name
                    drawObjs.text.Position = Vector2.new(minX + (drawObjs.box.Size.X / 2), minY - 20)
                    drawObjs.text.Visible = true
                else
                    drawObjs.box.Visible = false
                    drawObjs.text.Visible = false
                end
            end
        end
    else
        for _, drawObjs in pairs(playerBoxes) do
            drawObjs.box.Visible = false
            drawObjs.text.Visible = false
        end
    end

    -- Brainrot Gods ESP (blue)
    if godsESPEnabled then
        for _, npc in pairs(Workspace:GetChildren()) do
            if npc:IsA("Model") and brainrotGodRates[npc.Name] then
                local hrp = npc:FindFirstChild("HumanoidRootPart")
                local drawObjs = godsBoxes[npc]
                if hrp then
                    if not drawObjs then
                        godsBoxes[npc] = createESPBox(Color3.fromRGB(0, 170, 255))
                        drawObjs = godsBoxes[npc]
                    end
                    local pos, onScreen = camera:WorldToViewportPoint(hrp.Position)
                    if onScreen then
                        local size = Vector3.new(2, 5, 2)
                        local corners = {
                            camera:WorldToViewportPoint(hrp.Position + Vector3.new(-size.X, size.Y, -size.Z)),
                            camera:WorldToViewportPoint(hrp.Position + Vector3.new(size.X, size.Y, -size.Z)),
                            camera:WorldToViewportPoint(hrp.Position + Vector3.new(-size.X, size.Y, size.Z)),
                            camera:WorldToViewportPoint(hrp.Position + Vector3.new(size.X, size.Y, size.Z)),
                            camera:WorldToViewportPoint(hrp.Position + Vector3.new(-size.X, -size.Y, -size.Z)),
                            camera:WorldToViewportPoint(hrp.Position + Vector3.new(size.X, -size.Y, -size.Z)),
                            camera:WorldToViewportPoint(hrp.Position + Vector3.new(-size.X, -size.Y, size.Z)),
                            camera:WorldToViewportPoint(hrp.Position + Vector3.new(size.X, -size.Y, size.Z)),
                        }
                        local xs, ys = {}, {}
                        for _, corner in pairs(corners) do
                            table.insert(xs, corner.X)
                            table.insert(ys, corner.Y)
                        end
                        local minX, maxX = math.min(table.unpack(xs)), math.max(table.unpack(xs))
                        local minY, maxY = math.min(table.unpack(ys)), math.max(table.unpack(ys))

                        drawObjs.box.Position = Vector2.new(minX, minY)
                        drawObjs.box.Size = Vector2.new(maxX - minX, maxY - minY)
                        drawObjs.box.Visible = true

                        local info = brainrotGodRates[npc.Name]
                        drawObjs.text.Text = npc.Name .. "\n" .. info.moneyPerSec .. "/sec\nSell: " .. info.sellsFor
                        drawObjs.text.Position = Vector2.new(minX + (drawObjs.box.Size.X / 2), minY - 40)
                        drawObjs.text.Visible = true
                    else
                        drawObjs.box.Visible = false
                        drawObjs.text.Visible = false
                    end
                elseif drawObjs then
                    drawObjs.box.Visible = false
                    drawObjs.text.Visible = false
                    godsBoxes[npc] = nil
                end
            end
        end
    else
        for npc, drawObjs in pairs(godsBoxes) do
            drawObjs.box.Visible = false
            drawObjs.text.Visible = false
        end
    end

    -- Mythics ESP (red)
    if mythicsESPEnabled then
        for _, npc in pairs(Workspace:GetChildren()) do
            if npc:IsA("Model") and mythicRates[npc.Name] then
                local hrp = npc:FindFirstChild("HumanoidRootPart")
                local drawObjs = mythicsBoxes[npc]
                if hrp then
                    if not drawObjs then
                        mythicsBoxes[npc] = createESPBox(Color3.fromRGB(255, 50, 50))
                        drawObjs = mythicsBoxes[npc]
                    end
                    local pos, onScreen = camera:WorldToViewportPoint(hrp.Position)
                    if onScreen then
                        local size = Vector3.new(2, 5, 2)
                        local corners = {
                            camera:WorldToViewportPoint(hrp.Position + Vector3.new(-size.X, size.Y, -size.Z)),
                            camera:WorldToViewportPoint(hrp.Position + Vector3.new(size.X, size.Y, -size.Z)),
                            camera:WorldToViewportPoint(hrp.Position + Vector3.new(-size.X, size.Y, size.Z)),
                            camera:WorldToViewportPoint(hrp.Position + Vector3.new(size.X, size.Y, size.Z)),
                            camera:WorldToViewportPoint(hrp.Position + Vector3.new(-size.X, -size.Y, -size.Z)),
                            camera:WorldToViewportPoint(hrp.Position + Vector3.new(size.X, -size.Y, -size.Z)),
                            camera:WorldToViewportPoint(hrp.Position + Vector3.new(-size.X, -size.Y, size.Z)),
                            camera:WorldToViewportPoint(hrp.Position + Vector3.new(size.X, -size.Y, size.Z)),
                        }
                        local xs, ys = {}, {}
                        for _, corner in pairs(corners) do
                            table.insert(xs, corner.X)
                            table.insert(ys, corner.Y)
                        end
                        local minX, maxX = math.min(table.unpack(xs)), math.max(table.unpack(xs))
                        local minY, maxY = math.min(table.unpack(ys)), math.max(table.unpack(ys))

                        drawObjs.box.Position = Vector2.new(minX, minY)
                        drawObjs.box.Size = Vector2.new(maxX - minX, maxY - minY)
                        drawObjs.box.Visible = true

                        local info = mythicRates[npc.Name]
                        drawObjs.text.Text = npc.Name .. "\n" .. info.moneyPerSec .. "/sec\nSell: " .. info.sellsFor
                        drawObjs.text.Position = Vector2.new(minX + (drawObjs.box.Size.X / 2), minY - 40)
                        drawObjs.text.Visible = true
                    else
                        drawObjs.box.Visible = false
                        drawObjs.text.Visible = false
                    end
                elseif drawObjs then
                    drawObjs.box.Visible = false
                    drawObjs.text.Visible = false
                    mythicsBoxes[npc] = nil
                end
            end
        end
    else
        for npc, drawObjs in pairs(mythicsBoxes) do
            drawObjs.box.Visible = false
            drawObjs.text.Visible = false
        end
    end
end)

-- GUI Buttons for Mys2 Hub
autoToggle("Speed", function(enabled)
    speedEnabled = enabled
    if enabled then
        startSpeedEnforcement()
        hookWalkSpeed()
    else
        stopSpeedEnforcement()
    end
end)

autoToggle("Player ESP", function(enabled)
    playerESPEnabled = enabled
end)

autoToggle("Brainrot Gods ESP", function(enabled)
    godsESPEnabled = enabled
end)

autoToggle("Mythics ESP", function(enabled)
    mythicsESPEnabled = enabled
end)

autoButton("TP Up", tpUp)
autoButton("TP Down", tpDown)
autoButton("TP Closest Player", teleportToClosest)

-- Server hop stub (you'll need to implement actual server hopping logic)
autoButton("Server Hop", function()
    print("Server hopping... (feature needs implementation)")
end)

-- Send Discord webhook notification and show popup invite on script load
sendDiscordWebhookNotification()
showDiscordPopup()

-- Mys2 Fling GUI

local flingGui = Instance.new("ScreenGui", game.CoreGui)
flingGui.Name = "Mys2Fling"

local flingFrame = Instance.new("Frame", flingGui)
flingFrame.Size = UDim2.new(0, 220, 0, 100)
flingFrame.Position = UDim2.new(0, 250, 0, 100)
flingFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
flingFrame.BorderSizePixel = 0
flingFrame.Active = true
flingFrame.Draggable = true

local flingTitle = Instance.new("TextLabel", flingFrame)
flingTitle.Size = UDim2.new(1, 0, 0, 30)
flingTitle.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
flingTitle.Text = "Mys2 Fling"
flingTitle.TextColor3 = Color3.new(1, 1, 1)
flingTitle.Font = Enum.Font.GothamBold
flingTitle.TextSize = 16

local flingButton = Instance.new("TextButton", flingFrame)
flingButton.Size = UDim2.new(0, 200, 0, 40)
flingButton.Position = UDim2.new(0, 10, 0, 50)
flingButton.BackgroundColor3 = Color3.fromRGB(150, 0, 0)
flingButton.TextColor3 = Color3.new(1, 1, 1)
flingButton.Font = Enum.Font.GothamBold
flingButton.TextSize = 18
flingButton.Text = "Fling Me Out!"

local flingCooldown = false

flingButton.MouseButton1Click:Connect(function()
    if flingCooldown then return end
    flingCooldown = true

    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        warn("Character or HumanoidRootPart not found.")
        flingCooldown = false
        return
    end

    local hrp = player.Character.HumanoidRootPart

    -- Teleport to corner of the map (example coordinates)
    local cornerPosition = Vector3.new(-3000, 1000, -3000)
    hrp.CFrame = CFrame.new(cornerPosition)

    -- Apply velocity for fling effect
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(1e5, 1e5, 1e5)
    bodyVelocity.Velocity = Vector3.new(0, 200, 0) -- fling upwards strongly
    bodyVelocity.Parent = hrp

    -- Remove BodyVelocity after 1 second
    delay(1, function()
        bodyVelocity:Destroy()
        flingCooldown = false
    end)
end)
